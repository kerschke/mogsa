% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/exploreEfficientSet.R
\name{exploreEfficientSet}
\alias{exploreEfficientSet}
\title{Explore locally efficient set.}
\usage{
exploreEfficientSet(ind, fn, gradient.mat,
  max.no.steps.exploration = 400L, exploration.step = 0.2,
  prec.grad = 1e-06, prec.norm = 1e-06, prec.angle = 1e-04,
  check.data = TRUE, show.info = TRUE)
}
\arguments{
\item{ind}{[\code{\link{numeric}(d)}]\cr
d-dimensional individual.}

\item{max.no.steps.exploration}{[\code{\link{integer}(1L)}]\cr
Maximum number of steps performed (per objective) when exploring the local efficient set.
The only purpose of this value is to avoid infinite loops and thus can be set higher than
the default value (\code{400L}).}

\item{exploration.step}{[\code{\link{numeric}(1L)}]\cr
Scaling factor for the step size, when exploring a local efficient set.
The default is \code{0.2}.}

\item{prec.grad}{[\code{\link{numeric}(1L)}]\cr
Precision value (= step size) used for approximating the gradient. The default is \code{1e-6}.}

\item{prec.norm}{[\code{\link{numeric}(1L)}]\cr
Precision threshold when normalizing a vector. That is, every element of the vector,
whose absolute value is below this threshold, will be replaced by 0.
The default is \code{1e-6}.}

\item{prec.angle}{[\code{\link{numeric}(1L)}]\cr
Precision threshold used for comparing whether the angle (in degree) between two
vectors is zero. The default is \code{1e-4}.}

\item{check.data}{[\code{\link{logical}(1L)}]\cr
Should sanity checks be performed? The default is \code{TRUE}. Note that the checks
should only be turned off (e.g., for a slight speed up), if you are sure that you
provide the input data in the correct format.}

\item{show.info}{[\code{\link{logical}(1L)}]\cr
Should the called method provide further information on the console?
The default is \code{TRUE}.}

\item{fn1}{[\code{\link{function}}]\cr
The first objective used for computing the multi-objective gradient.}

\item{fn2}{[\code{\link{function}}]\cr
The second objective used for computing the multi-objective gradient.}

\item{gradient.list}{[\code{\link{list}(p)}]\cr
A list with the single-objective gradients of the p objectives. Per default
each of the p elements of this list is NULL, implying that the respective
gradients will be approximated using \code{\link{estimateGradientBothDirections}}.}

\item{lower}{[\code{\link{numeric}(d)}]\cr
Vector of lower bounds.}

\item{upper}{[\code{\link{numeric}(d)}]\cr
Vector of upper bounds.}
}
\value{
[\code{\link{list}(4)}]\cr
  Returns a list with four elements. The first one provides the points that were found
  to be part of the efficient set.\cr
  The second element lists the corresponding number of performed function evaluations.\cr
  The third and fourth elements are lists, containing information on the edges of the
  efficient set. This information consists of a \code{\link{logical}} indicating whether
  it could be confirmed that the found efficient set definitely is only a local efficient
  set. Important note: a value of \code{FALSE} does not imply that the found efficient set
  has to be globally efficient, as it could also be a multi-objective trap. In addition
  those two sublists also contain the actual positions of the evaluated points outside
  the efficient set, their single-objective gradients as well as the number of function
  evaluations (per objective) performed to compute these gradients.\cr
  Note that these (up to two) points (\code{end1$external} and \code{end2$external})
  are reasonable starting points for a gradient descent towards a better efficient set.
}
\description{
Explores a locally efficient set separately along the gradients of the two objectives
  \code{fn1} and \code{fn2}. Both explorations initially start in point \code{ind}. Such
  explorations obviously are only reasonable, if \code{ind} is a locally efficient point.
  See \code{\link{findLocallyEfficientPoint}} for further details.
}
\note{
ATTENTION: Only turn off the sanity checks (\code{check.data = FALSE}),
  if you can ensure that all input parameters are provided in the correct format.
}
\examples{
# Define two single-objective test problems:
fn1 = function(x) sum((x - c(0.2, 1))^2)
fn2 = function(x) 2 * x[1]^2 - x[1] * x[2] + 0.3 * x[2]^2

# c(0.2, 1) is obviously a local optimum of fn1, so let's explore the efficient set from there:
exploreEfficientSet(c(0.2, 1), fn1, fn2, max.no.steps.exploration = 50L, exploration.step = 0.05)
}
