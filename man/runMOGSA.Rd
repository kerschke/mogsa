% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runMOGSA.R
\name{runMOGSA}
\alias{runMOGSA}
\title{Run MOGSA.}
\usage{
runMOGSA(ind, fn = NULL, max.no.basins = 15L, max.no.steps.ls = 600L,
  max.no.steps.exploration = 100L, scale.step = 0.5,
  exploration.step = 0.2, prec.grad = 1e-06, prec.norm = 1e-06,
  prec.angle = 1e-04, ls.method = "both", check.data = TRUE,
  show.info = TRUE, allow.restarts = TRUE)
}
\arguments{
\item{ind}{[\code{\link{numeric}(d)}]\cr
d-dimensional individual.}

\item{fn}{[\code{\link{function}}]\cr
Bi-objective problem to be optimized. Note that this function
will only be considered, if its single objectives (\code{fn1} and/or
\code{fn2}) are not provided.}

\item{max.no.basins}{[\code{\link{integer}(1L)}]\cr
Maximum number of basins allowed to visit on the way to the optimum.
The default is \code{50L}.}

\item{max.no.steps.ls}{[\code{\link{integer}(1L)}]\cr
Maximum number of steps performed to find a locally efficient point.
The default is \code{500L}.}

\item{max.no.steps.exploration}{[\code{\link{integer}(1L)}]\cr
Maximum number of steps performed (per objective) when exploring the local efficient set.
The only purpose of this value is to avoid infinite loops and thus can be set higher than
the default value (\code{400L}).}

\item{scale.step}{[\code{\link{numeric}(1L)}]\cr
Scaling factor for the step size in the direction of the multi-objective gradient.
The default is \code{0.5}.}

\item{exploration.step}{[\code{\link{numeric}(1L)}]\cr
Scaling factor for the step size, when exploring a local efficient set.
The default is \code{0.2}.}

\item{prec.grad}{[\code{\link{numeric}(1L)}]\cr
Precision value (= step size) used for approximating the gradient. The default is \code{1e-6}.}

\item{prec.norm}{[\code{\link{numeric}(1L)}]\cr
Precision threshold when normalizing a vector. That is, every element of the vector,
whose absolute value is below this threshold, will be replaced by 0.
The default is \code{1e-6}.}

\item{prec.angle}{[\code{\link{numeric}(1L)}]\cr
Precision threshold used for comparing whether the angle (in degree) between two
vectors is zero. The default is \code{1e-4}.}

\item{ls.method}{[\code{\link{character}(1L)}]\cr
Select between two possible local search methods: weighted bisection
(\code{"bisection"}), multi-objective local search (\code{"mo-ls"})
or \code{"both"} (sequentially). The default is \code{"both"}.}

\item{check.data}{[\code{\link{logical}(1L)}]\cr
Should sanity checks be performed? The default is \code{TRUE}. Note that the checks
should only be turned off (e.g., for a slight speed up), if you are sure that you
provide the input data in the correct format.}

\item{show.info}{[\code{\link{logical}(1L)}]\cr
Should the called method provide further information on the console?
The default is \code{TRUE}.}

\item{allow.restarts}{[\code{\link{logical}(1L)}]\cr
Should the algorithm be allowed to perform restarts?
The default is \code{TRUE}.}

\item{fn1}{[\code{\link{function}}]\cr
The first objective used for computing the multi-objective gradient.}

\item{fn2}{[\code{\link{function}}]\cr
The second objective used for computing the multi-objective gradient.}

\item{lower}{[\code{\link{numeric}(d)}]\cr
Vector of lower bounds.}

\item{upper}{[\code{\link{numeric}(d)}]\cr
Vector of upper bounds.}
}
\value{
[\code{\link{matrix}}]\cr
  Returns MOGSA's optimization path, consisting of the visited individuals
  (\code{x1} and \code{x2}) and the visited basins (\code{basin}). Furthermore
  the sequential \code{iterations} performed per basin and phase of the algorithm
  (start, local search, exploration and external points), as well as the actual
  phases (\code{type}) are provided. The external points result from evaluations
  during the exploration phase, in which the algorithm actually evaluated a point
  outside of the efficient set.
}
\description{
Starting from a specific point \code{ind} in the search space, MOGSA will perform
  multiple iterations of (a) multi-objective gradient descent towards a local efficient
  point, and (b) exploration of the efficient set to which the recently found efficient
  point belongs. These two phases are alternatively executed until the maximum number
  of visited basins (\code{max.no.basins}) was reached or the algorithm has found
  a global efficient set (or at least a multi-objective trap).
}
\note{
ATTENTION: Only turn off the sanity checks (\code{check.data = FALSE}),
  if you can ensure that all input parameters are provided in the correct format.
}
\examples{
## Example 1:
# (i) Define two single-objective test problems (fn1, fn2) and a starting point (ind):
fn1 = function(x) sum((x - c(2, 0))^2)
fn2 = function(x) sum((x - c(0, 1))^2)
ind = c(1, 1)

# (ii) Visualize locally efficient set, i.e., the "area" (here: line), of globally
# non-dominated points:
plot(c(2, 0), c(0, 1), type = "o", pch = 19, lty = 2,
  xlim = c(-0.2, 2.2), ylim = c(-0.1, 1.1),
  xlab = expression(x[1]), ylab = expression(x[2]), las = 1, asp = 1)
text(2, 0, "Optimum of fn1", pos = 2, offset = 1.5)
text(0, 1, "Optimum of fn2", pos = 4, offset = 1.5)

# (iii) Run MOGSA:
mogsa.result = runMOGSA(ind = ind, fn1 = fn1, fn2 = fn2)

# (iv) Visualize the optimization path of MOGSA:
points(mogsa.result[, c("x1", "x2")],
  col = as.integer(mogsa.result$type) + 1L,
  pch = as.integer(mogsa.result$type) + 14L)
legend("topright", pch = 15:18, col = 2:5, legend = levels(mogsa.result$type))
}
