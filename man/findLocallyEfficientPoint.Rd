% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/findLocallyEfficientPoint.R
\name{findLocallyEfficientPoint}
\alias{findLocallyEfficientPoint}
\title{Find locally efficient point.}
\usage{
findLocallyEfficientPoint(
  ind,
  fn,
  gradient.mat,
  max.no.steps.ls = 500L,
  scale.step = 0.5,
  prec.grad = 1e-06,
  prec.norm = 1e-06,
  prec.angle = 1e-04,
  ls.method = "both",
  check.data = TRUE,
  show.info = TRUE,
  allow.restarts = TRUE
)
}
\arguments{
\item{ind}{[\code{\link{numeric}(d)}]\cr
d-dimensional individual.}

\item{max.no.steps.ls}{[\code{\link{integer}(1L)}]\cr
Maximum number of steps performed to find a locally efficient point.
The default is \code{500L}.}

\item{scale.step}{[\code{\link{numeric}(1L)}]\cr
Scaling factor for the step size in the direction of the multi-objective gradient.
The default is \code{0.5}.}

\item{prec.grad}{[\code{\link{numeric}(1L)}]\cr
Precision value (= step size) used for approximating the gradient. The default is \code{1e-6}.}

\item{prec.norm}{[\code{\link{numeric}(1L)}]\cr
Precision threshold when normalizing a vector. That is, every element of the vector,
whose absolute value is below this threshold, will be replaced by 0.
The default is \code{1e-6}.}

\item{prec.angle}{[\code{\link{numeric}(1L)}]\cr
Precision threshold used for comparing whether the angle (in degree) between two
vectors is zero. The default is \code{1e-4}.}

\item{ls.method}{[\code{\link{character}(1L)}]\cr
Select between two possible local search methods: weighted bisection
(\code{"bisection"}), multi-objective local search (\code{"mo-ls"})
or \code{"both"} (sequentially). The default is \code{"both"}.}

\item{check.data}{[\code{\link{logical}(1L)}]\cr
Should sanity checks be performed? The default is \code{TRUE}. Note that the checks
should only be turned off (e.g., for a slight speed up), if you are sure that you
provide the input data in the correct format.}

\item{show.info}{[\code{\link{logical}(1L)}]\cr
Should the called method provide further information on the console?
The default is \code{TRUE}.}

\item{allow.restarts}{[\code{\link{logical}(1L)}]\cr
Should the algorithm be allowed to perform restarts?
The default is \code{TRUE}.}

\item{fn1}{[\code{\link{function}}]\cr
The first objective used for computing the multi-objective gradient.}

\item{fn2}{[\code{\link{function}}]\cr
The second objective used for computing the multi-objective gradient.}

\item{gradient.list}{[\code{\link{list}(p)}]\cr
A list with the single-objective gradients of the p objectives. Per default
each of the p elements of this list is NULL, implying that the respective
gradients will be approximated using \code{\link{estimateGradientBothDirections}}.}

\item{lower}{[\code{\link{numeric}(d)}]\cr
Vector of lower bounds.}

\item{upper}{[\code{\link{numeric}(d)}]\cr
Vector of upper bounds.}
}
\value{
[\code{\link{list}(3L)}]\cr
  Returns a list, whose first element (\code{opt.path}) provides the matrix
  of the optimization path, which has been evaluated on the way to a locally
  efficient point. As the 1st row represents the initial individual
  (\code{ind}), the i-th row corresponds to the (i-1)-th individual.\cr
  The second element of the list (\code{fn.evals}) contains a matrix with
  the corresponding number of function evaluations per objective. As a
  result, this matrix consists of \code{p} columns and as many rows as
  \code{opt.path}.\cr
  The final list element (\code{gradient.list}) provides another list, whose
  \code{p} elements provide the single-objective gradients of the last
  individual from \code{opt.path}. This information might be used to safe
  function evaluations when proceeding with that particular individual
  (e.g., when exploring a potential existing efficient set).
}
\description{
Performs sequential downhill steps in the direction of the multi-objective gradient
  until a locally efficient point was found. The latter possess a multi-objective
  gradient of length zero (see \code{\link{performGradientStep}} for details) as the
  normalized gradients of its objectives cancel each other out.\cr
  Note that once the local search detects that it crossed the optimum (i.e., the
  multi-objective gradients of succeeding iterations show in opposite directions),
  it will perform a weighted bisection optimization to find a local efficient point.
  See \code{\link{performWeightedBisectionOptimization}} for further details on the
  latter.
}
\note{
ATTENTION: Only turn off the sanity checks (\code{check.data = FALSE}),
  if you can ensure that all input parameters are provided in the correct format.
}
\examples{
# Define two single-objective test problems:
fn1 = function(x) sum((x - c(2, 0))^2)
fn2 = function(x) sum((x - c(0, 1))^2)
fn = function(x) return(c(fn1(x), fn2(x)))

# Visualize locally efficient set, i.e., the "area" where we ideally want to find a point:
plot(c(2, 0), c(0, 1), type = "o", pch = 19,
  xlab = expression(x[1]), ylab = expression(x[2]), las = 1, asp = 1)
text(2, 0, "Optimum of fn1", pos = 2, offset = 1.5)
text(0, 1, "Optimum of fn2", pos = 4, offset = 1.5)

# Place two points x1 and x2 on opposite sides of the bi-objective optimum:
x.start = c(0.3, 0.5)
points(rbind(x.start), pch = 19, type = "o", lty = "dotted")
text(rbind(x.start), labels = c("start"), pos = 2)

# Visualize path of bisection search in blue
res.bisection = findLocallyEfficientPoint(c(0.3, 0.5), fn, ls.method = "bisection")
points(res.bisection$opt.path, pch = 20, lty = 2, type = "o", col = "blue")

# Visualize path of multi-objective local search in red
res.mo.ls = findLocallyEfficientPoint(c(0.3, 0.5), fn, ls.method = "mo-ls")
points(res.mo.ls$opt.path, pch = 20, lty = 2, type = "o", col = "red")
}
