% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/performWeightedBisectionOptimization.R
\name{performWeightedBisectionOptimization}
\alias{performWeightedBisectionOptimization}
\title{Performs a weighted bi-section optimization.}
\usage{
performWeightedBisectionOptimization(x1, x2, fn1, fn2, g1 = NULL,
  g2 = NULL, prec.grad = 1e-06, prec.norm = 1e-06,
  max.steps = 1000L, lower, upper)
}
\arguments{
\item{x1}{[\code{\link{numeric}(d)}]\cr
d-dimensional individual located on one side of the (bi-objective) optimum.}

\item{x2}{[\code{\link{numeric}(d)}]\cr
d-dimensional individual located on the opposite side (w.r.t. x1) of the (bi-objective) optimum.}

\item{fn1}{[\code{\link{function}}]\cr
The first objective used for computing the multi-objective gradient.}

\item{fn2}{[\code{\link{function}}]\cr
The second objective used for computing the multi-objective gradient.}

\item{g1}{[\code{\link{function}}]\cr
The gradient of the first objective in \code{ind}. If missing, it will
be approximated using \code{\link{estimateGradientBothDirections}}.}

\item{g2}{[\code{\link{function}}]\cr
The gradient of the second objective in \code{ind}. If missing, it will
be approximated using \code{\link{estimateGradientBothDirections}}.}

\item{prec.grad}{[\code{\link{numeric}(1L)}]\cr
Precision value (= step size) used for approximating the gradient. The default is \code{1e-6}.}

\item{prec.norm}{[\code{\link{numeric}(1L)}]\cr
Precision threshold when normalizing a vector. That is, every element of the vector,
whose absolute value is below this threshold, will be replaced by 0.
The default is \code{1e-6}.}

\item{max.steps}{[\code{\link{integer}(1L)}]
Maximum number of allowed bi-section steps to reach an optimum. The default is \code{1000L}.}

\item{lower}{[\code{\link{numeric}(d)}]\cr
Vector of lower bounds.}

\item{upper}{[\code{\link{numeric}(d)}]\cr
Vector of upper bounds.}
}
\value{
[\code{\link{list}(4L)}]\cr
  List containing a matrix (\code{opt.path}) with the individuals along the optimization path,
  the corresponding number of function evaluations (\code{fn.evals}), the single-objective
  gradients of the last individual (\code{gradient.list}) and a flag, indicating whether the
  optimizer found a local optimum.
}
\description{
Weighted version of the bisection optimization method. Given two points \code{x1} and \code{x2} on opposite
  sides of the optimum, this optimizer iteratively splits the interval [\code{x1}, \code{x2}] into two parts
  [\code{x1}, \code{x.new}] and [\code{x.new}, \code{x2}] and proceeds with the interval, whose boundaries are
  still located on opposite sides of the optimum. Instead to the \href{https://en.wikipedia.org/wiki/Bisection_method}{classical bisection method},
  where \code{x.new} is the arithmetic mean of \code{x1} and \code{x2}, this version uses the lengths of the
  bi-objective gradients in \code{x1} and \code{x2} to compute a more promising cut-point \code{x.new}.
}
\examples{
# Define two single-objective test problems:
fn1 = function(x) sum((x - c(2, 0))^2)
fn2 = function(x) sum((x - c(0, 1))^2)

# Visualize locally efficient set, i.e., the "area" where we ideally want to find a point:
plot(c(2, 0), c(0, 1), type = "o", pch = 19,
  xlab = expression(x[1]), ylab = expression(x[2]), las = 1, asp = 1)
text(2, 0, "Optimum of fn1", pos = 2, offset = 1.5)
text(0, 1, "Optimum of fn2", pos = 4, offset = 1.5)

# Place two points x1 and x2 on opposite sides of the bi-objective optimum:
x1 = c(1, 1)
x2 = c(0.5, 0)
points(rbind(x1, x2), pch = 19, type = "o", lty = "dotted")
text(rbind(x1, x2), labels = c("x1", "x2"), pos = 4)

# Optimize using weighted bisection optimization:
opt.path = performWeightedBisectionOptimization(x1 = x1, x2 = x2, fn1 = fn1, fn2 = fn2)$opt.path

# Visualize the optimization path:
points(opt.path)

# Highlight the found local efficient point (= local optimum w.r.t. both objectives):
n = nrow(opt.path)
points(opt.path[n, 1], opt.path[n, 2], pch = 4, col = "red", cex = 2)
text(opt.path[n, 1], opt.path[n, 2], "Found Local Efficient Point", pos = 4, offset = 1.5)
}
